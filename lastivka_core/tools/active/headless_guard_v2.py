# AUTOGENERATED by self_programmer.py — DO NOT EDIT BY HAND
"""
Leaf tool: headless_guard
Goal: provide headless-guard decisions (boot directives + strategy hints) for hiding GUI artifacts
Policy: stdlib-only; forbidden: os, subprocess, socket, file I/O, eval/exec/compile/globals/locals/memoryview.
"""

import json
import re
import math
import statistics
import hashlib
from typing import Dict, Any, List

META = {
    "name": "headless_guard",
    "goal": "headless guard (boot directives + strategy hints)",
    "version": 2,
    "policy": "safe-leaf",
}


def _validate_inputs(args: dict) -> dict:
    if not isinstance(args, dict):
        raise TypeError("run() expects kwargs dict")
    return args


def selftest():
    # Basic META checks
    assert isinstance(META["name"], str) and META["name"], "empty name"
    assert META["policy"] == "safe-leaf"

    # Legacy/boot behavior must exist
    boot = run(op="boot")
    assert isinstance(boot, dict)
    assert "directives" in boot and isinstance(boot["directives"], list)
    assert "enforce_headless" in boot["directives"]
    assert "normalize_interpreter" in boot["directives"]

    # Strategy behavior must exist and be deterministic
    out = run(mode="default", hints={"pythonw_window_seen": True, "no_console_needed": True})
    assert isinstance(out, dict)
    assert "strategy" in out and "explain" in out and "meta" in out
    assert out["strategy"] in {"noop", "job_object_hide", "detach_handles", "create_no_window"}

    out2 = run(mode="default", hints={"pythonw_window_seen": True, "no_console_needed": True})
    assert out == out2


def _decide_strategy(mode: str, hints: Dict[str, Any]) -> Dict[str, Any]:
    """
    Pure stdlib heuristic. Returns {"strategy": str, "score": int, "explain": str}.
    """
    score = 0
    if hints.get("pythonw_window_seen"):      # користувач бачив спалах GUI
        score += 2
    if hints.get("uses_win32job"):            # раннер уміє прикріпити Job Object
        score += 1
    if hints.get("no_console_needed"):        # сервісний/daemon-подібний запуск
        score += 1

    m = mode.lower().strip()
    if m == "aggressive":
        score += 1
    elif m == "compat":
        score -= 1
    else:
        # "default" або інше — без зсувів
        pass

    if score >= 3:
        strategy = "job_object_hide"          # пріоритет Job Object + неуспадковані дескриптори
    elif score <= 0:
        strategy = "noop"                     # нічого не робити
    else:
        # Серединний варіант: створити процес без вікна або розірвати дескриптори консолі
        strategy = "create_no_window" if hints.get("supports_create_no_window") else "detach_handles"

    explain = (
        f"mode={m}, hints={sorted([k for k,v in hints.items() if v])}, score={score}. "
        "Leaf-tool повертає лише ярлик стратегії; реальні OS-дії виконує раннер."
    )
    return {"strategy": strategy, "score": score, "explain": explain}


def run(**kwargs) -> Dict[str, Any]:
    """
    Dual-mode guard:
      1) op='boot'  → повертає директиви раннього headless-запуску (без жодних OS-викликів тут).
      2) strategy   → за режимом/підказками повертає ярлик стратегії (runner застосує його на ОС-рівні).

    Args:
      op: 'boot' | None
      mode: 'default' | 'aggressive' | 'compat'
      hints: dict, напр. {"pythonw_window_seen": True, "uses_win32job": True, "no_console_needed": True,
                          "supports_create_no_window": True}
    """
    args = _validate_inputs(kwargs)

    # === Legacy / Boot directives ===
    if str(args.get("op", "")).lower() == "boot":
        # Мінімальні вказівки для раннього запуску без вікон
        directives: List[str] = ["enforce_headless", "normalize_interpreter"]
        params: Dict[str, Any] = {
            # Це лише дані — раннер вирішує, що саме робити на ОС-рівні
            "prefer_create_no_window": True,
            "detach_inherited_console": True,
        }
        return {
            "directives": directives,
            "params": params,
            "meta": {"tool": META["name"], "version": META["version"]},
        }

    # === Strategy hints ===
    mode = str(args.get("mode", "default"))
    hints = args.get("hints") or {}
    if not isinstance(hints, dict):
        hints = {}

    s = _decide_strategy(mode, hints)
    return {
        "strategy": s["strategy"],
        "score": s["score"],
        "explain": s["explain"],
        "meta": {"tool": META["name"], "version": META["version"]},
    }
