param(
  [string]$Root    = "C:\Lastivka\gateway\cloud_mailbox",
  [int]   $PollSec = 5
)

# === LOG PATHS ===
$watcherLog = Join-Path $Root 'logs\watcher.log'   # службовий лог watcher-а
$gatewayLog = Join-Path $Root 'logs\gateway.log'   # лог, який може крутити logs.rotate

# Folders & flags
$inbox      = Join-Path $Root 'inbox'
$outbox     = Join-Path $Root 'outbox'
$archive    = Join-Path $Root 'archive'
$quarantine = Join-Path $Root 'quarantine'
$allowFlag  = "C:\Lastivka\ALLOW_APPLY.flag"
$stopFlag   = Join-Path $Root 'STOP.flag'

# Whitelist (дозволені фокуси)
$WhitelistFocus = @('verify.integrity','logs.rotate','memory.optimization','report.daily')

# Ensure structure
New-Item $inbox,$outbox,$archive,$quarantine,(Split-Path $watcherLog) -ItemType Directory -Force | Out-Null
New-Item (Split-Path $gatewayLog) -ItemType Directory -Force | Out-Null

function Write-LineSafe {
  param(
    [Parameter(Mandatory=$true)][string]$Path,
    [Parameter(Mandatory=$true)][string]$Line,
    [int]$Retries = 8,
    [int]$DelayMs = 120
  )
  for($i=0; $i -lt $Retries; $i++){
    try{
      New-Item -ItemType Directory -Force -Path (Split-Path $Path) | Out-Null
      $fs = [System.IO.File]::Open(
        $Path,
        [System.IO.FileMode]::Append,
        [System.IO.FileAccess]::Write,
        [System.IO.FileShare]::ReadWrite
      )
      try{
        $enc = [System.Text.UTF8Encoding]::new($false)
        $sw  = New-Object System.IO.StreamWriter($fs, $enc)
        $sw.WriteLine($Line)
        $sw.Flush()
        $sw.Dispose()
      } finally {
        $fs.Dispose()
      }
      break
    } catch {
      if($i -ge $Retries-1){ throw }
      Start-Sleep -Milliseconds $DelayMs
    }
  }
}

function W-Log([string]$msg){
  try{
    $ts = (Get-Date).ToString('s')
    Write-LineSafe -Path $watcherLog -Line ("{0} {1}" -f $ts, $msg)
  } catch { }
}

function Get-PayloadHash([Parameter(Mandatory=$true)][ValidateNotNullOrEmpty()][string]$p){
  if (-not $p -or $p -eq "") { return $null }
  if (-not (Test-Path $p))   { return $null }
  try {
    $o = (Get-Content $p -Raw -Encoding UTF8) | ConvertFrom-Json -ErrorAction Stop
    if ($o.PSObject.Properties['sha256']) { $o.PSObject.Properties.Remove('sha256') | Out-Null }
    $payload = $o | ConvertTo-Json -Depth 20 -Compress
    $b = [Text.Encoding]::UTF8.GetBytes($payload)
    $s = [Security.Cryptography.SHA256]::Create()
    return ([BitConverter]::ToString($s.ComputeHash($b))).Replace('-','').ToLowerInvariant()
  } catch { return $null }
}

function Format-Bytes([long]$bytes){
  if($bytes -ge 1GB){ '{0:N2} GB' -f ($bytes/1GB) }
  elseif($bytes -ge 1MB){ '{0:N2} MB' -f ($bytes/1MB) }
  elseif($bytes -ge 1KB){ '{0:N2} KB' -f ($bytes/1KB) }
  else { "$bytes B" }
}

W-Log "watcher start (poll=$PollSec s)"

while($true){
  if(Test-Path $stopFlag){ W-Log "STOP.flag present -> idle"; Start-Sleep -Seconds ($PollSec*6); continue }

  $taskFile = Get-ChildItem $inbox -Filter '*.task.json' -File | Sort-Object LastWriteTime | Select-Object -First 1
  if(-not $taskFile){ Start-Sleep -Seconds $PollSec; continue }

  # Read task
  try { $task = Get-Content $taskFile.FullName -Raw -Encoding UTF8 | ConvertFrom-Json -ErrorAction Stop }
  catch { W-Log "bad json: $($taskFile.Name) -> quarantine"; Move-Item $taskFile.FullName (Join-Path $quarantine $taskFile.Name) -Force; Start-Sleep -Seconds 1; continue }

  # Basic checks
  if($task.sender -ne 'sofia'){ W-Log "sender not allowed: $($task.sender)"; Move-Item $taskFile.FullName (Join-Path $quarantine $taskFile.Name) -Force; continue }
  if(($task.focus -as [string]) -notin $WhitelistFocus){ W-Log "focus not allowed: $($task.focus)"; Move-Item $taskFile.FullName (Join-Path $quarantine $taskFile.Name) -Force; continue }

  # --- SAFE payload hash & ACK ---
  $payloadHash = Get-PayloadHash $taskFile.FullName
  if(-not $payloadHash){
    W-Log "hash calc failed -> quarantine: $($task.id)"
    Move-Item $taskFile.FullName (Join-Path $quarantine $taskFile.Name) -Force
    continue
  }
  $hashOk = ($task.sha256 -as [string]) -and ($payloadHash -as [string]) -and ($task.sha256.ToLower() -eq $payloadHash.ToLower())

  # ACK
  $ackObj = @{
    id=$task.id; ts=(Get-Date).ToString("s"); receiver="lastivka"; status="received"; version="gateway-1.0"; hash_ok=$hashOk
  }
  $ackObj | ConvertTo-Json -Depth 6 | Out-File (Join-Path $outbox "$($task.id).ack.json") -Encoding UTF8
  if(-not $hashOk){ W-Log "hash mismatch -> quarantine: $($task.id)"; Move-Item $taskFile.FullName (Join-Path $quarantine $taskFile.Name) -Force; continue }

  # Mode
  $dryRun = -not (Test-Path $allowFlag) -or ($task.limits.mode -ne 'safe')
  W-Log "task $($task.id) kind=$($task.kind) focus=$($task.focus) dryRun=$dryRun"

  # ---------------- HANDLERS ----------------
  $artifacts = @()
  $resultSummary = "watcher run (dryRun={0})" -f $dryRun
  $ok = $true

  if ($task.focus -eq 'verify.integrity') {
    $checks = @(
      'C:\Lastivka\memory',
      'C:\Lastivka\memory\snapshots',
      'C:\Lastivka\logs',
      'C:\Lastivka\indices'
    )
    $report = Join-Path $outbox ("verify_integrity_{0:yyyyMMdd_HHmmss}.txt" -f (Get-Date))
    $lines = @()
    foreach($p in $checks){
      $exists = Test-Path $p
      $lines += ("[{0}] {1}" -f ($(if($exists){'OK'}else{'MISS'}), $p))
      if(-not $exists){ $ok = $false }
    }
    $lines += ("allow_apply_flag: " + (Test-Path $allowFlag))
    $lines -join "`r`n" | Out-File $report -Encoding UTF8
    $artifacts += $report
    $resultSummary = ("verify.integrity: {0} paths checked; ok={1}" -f $checks.Count, $ok)
  }
  elseif ($task.focus -eq 'logs.rotate') {
    $thresholdBytes = 1MB
    $log = $gatewayLog    # <- єдина прив’язка
    $ok = $true

    if (Test-Path $log) { $size = (Get-Item $log).Length } else { $size = 0 }
    $needRotate = $size -ge $thresholdBytes

    $writes = ($task.limits.writes -as [string])
    $writesAllowed = $writes -and ($writes -in @('guarded','all'))

    if ($needRotate -and -not $dryRun -and $writesAllowed) {
      $stamp = Get-Date -Format 'yyyyMMdd_HHmmss'
      $rotated = Join-Path (Split-Path $log) ("gateway_{0}.log" -f $stamp)
      Move-Item $log $rotated -Force
      New-Item -ItemType File -Path $log -Force | Out-Null
      $artifacts += $rotated
      $resultSummary = ('logs.rotate: rotated at ~{0:N0} bytes -> {1}' -f $size, $rotated)
    }
    elseif ($needRotate -and -not $writesAllowed) {
      $resultSummary = ('logs.rotate: blocked (writes={0}) @ ~{1:N0} bytes' -f $writes, $size)
    }
    elseif ($needRotate -and $dryRun) {
      $resultSummary = ('logs.rotate: would rotate @ ~{0:N0} bytes (dryRun)' -f $size)
    }
    else {
      $resultSummary = ('logs.rotate: no action (size={0:N0} bytes)' -f $size)
    }
  }
  elseif ($task.focus -eq 'report.daily') {
    # Звіт про стан: CPU, RAM, диск, аптайм, розмір логів, прапорець застосування
    $now = Get-Date
    $os  = Get-CimInstance Win32_OperatingSystem
    $boot= $os.LastBootUpTime
    try { $cpu = (Get-Counter '\Processor(_Total)\% Processor Time' -SampleInterval 1 -MaxSamples 1).CounterSamples.CookedValue } catch { $cpu = $null }

    $totalMem = [int64]($os.TotalVisibleMemorySize * 1KB)
    $freeMem  = [int64]($os.FreePhysicalMemory    * 1KB)
    $usedMem  = $totalMem - $freeMem

    $sysDrive = (Get-PSDrive -PSProvider FileSystem | Where-Object {$_.Name -eq 'C'})
    $freeDisk = if($sysDrive){ [int64]$sysDrive.Free } else { 0 }
    $totDisk  = if($sysDrive){ [int64]$sysDrive.Used + [int64]$sysDrive.Free } else { 0 }

    if (Test-Path $gatewayLog) { $gLen = (Get-Item $gatewayLog).Length } else { $gLen = 0 }
    $uptime = (New-TimeSpan -Start $boot -End $now)

    $reportPath = Join-Path $outbox ("report_daily_{0:yyyyMMdd_HHmmss}.txt" -f $now)
    $lines = @()
    $lines += "REPORT DAILY @ {0:s}" -f $now
    $lines += "uptime: {0}d {1}h {2}m" -f $uptime.Days,$uptime.Hours,$uptime.Minutes
    $lines += "cpu.total: {0:N1} %" -f ($(if($cpu -ne $null){$cpu}else{-1}))
    $lines += "ram.used/total: {0} / {1}" -f (Format-Bytes $usedMem),(Format-Bytes $totalMem)
    if($totDisk -gt 0){ $lines += "disk(C:).free/total: {0} / {1}" -f (Format-Bytes $freeDisk),(Format-Bytes $totDisk) }
    $lines += "gateway.log: {0}" -f (Format-Bytes $gLen)
    $lines += "allow_apply_flag: {0}" -f (Test-Path $allowFlag)

    $lines -join "`r`n" | Out-File $reportPath -Encoding UTF8
    $artifacts += $reportPath
    $resultSummary = "report.daily: ok (cpu≈{0:N0}%, ram={1}/{2}, log={3})" -f ($(if($cpu -ne $null){$cpu}else{0})), (Format-Bytes $usedMem), (Format-Bytes $totalMem), (Format-Bytes $gLen)
  }
  elseif ($task.focus -eq 'memory.optimization') {
    # Безпечний план (тільки читання): список найбільших *.json у пам’яті
    $memRoot = 'C:\Lastivka\memory'
    $planPath = Join-Path $outbox ("memory_opt_plan_{0:yyyyMMdd_HHmmss}.txt" -f (Get-Date))
    $lines = @()
    $lines += "MEMORY OPT PLAN @ {0:s}" -f (Get-Date)

    if (Test-Path $memRoot) {
      $top = Get-ChildItem $memRoot -Recurse -ErrorAction SilentlyContinue |
             Where-Object { -not $_.PSIsContainer -and $_.Extension -match '\.json$' } |
             Sort-Object Length -Descending | Select-Object -First 20
      if($top){
        $lines += "top_json_by_size:"
        foreach($f in $top){
          $lines += ("  {0}  {1}" -f (Format-Bytes $f.Length), $f.FullName)
        }
      } else { $lines += "no json files found" }
    } else {
      $lines += "memory root not found: $memRoot"
      $ok = $false
    }

    $lines -join "`r`n" | Out-File $planPath -Encoding UTF8
    $artifacts += $planPath
    $resultSummary = "memory.optimization: plan generated (top 20 by size)"
  }
  else {
    # інші фокуси поки що не реалізовані
    Start-Sleep -Seconds ([math]::Min(($task.limits.max_runtime_s -as [int]), 5))
  }
  # -------------- END HANDLERS --------------

  # --- FINALIZE & WRITE STATUS (always) ---
  if (-not $resultSummary) { $resultSummary = "no summary" }
  if (-not $artifacts)     { $artifacts     = @() }
  if ($ok -isnot [bool])   { $ok = $true }
  $statusObj = [ordered]@{
    id        = $task.id
    ts        = (Get-Date).ToString("s")
    ok        = ($ok -as [bool])
    summary   = $resultSummary
    artifacts = $artifacts
  }
  $stPath = Join-Path $outbox ("{0}.status.json" -f $task.id)
  $statusObj | ConvertTo-Json -Depth 20 | Out-File $stPath -Encoding UTF8

  # ARCHIVE
  $day = (Get-Date).ToString("yyyyMMdd")
  $archDir = Join-Path $archive $day
  New-Item $archDir -ItemType Directory -Force | Out-Null
  Move-Item $taskFile.FullName (Join-Path $archDir $taskFile.Name) -Force
}
